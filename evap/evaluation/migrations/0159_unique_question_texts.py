# Generated by Django 5.2 on 2025-09-22 18:35
from collections import Counter
from io import StringIO
from typing import Literal

from django.db import IntegrityError, migrations, models


def check_consistent_question_texts(apps, _schema_editor) -> None:
    Question = apps.get_model("evaluation", "Question")
    texts_de, texts_en = zip(*Question.objects.values_list("text_de", "text_en").distinct(), strict=True)

    context = StringIO()

    def print_collision(texts, key: Literal["text_de", "text_en"]) -> bool:
        collisions = {text for (text, count) in Counter(texts).items() if count > 1}
        for collision in collisions:
            print(
                "\n".join(map(str, Question.objects.filter(**{key: collision}).values("id", "text_de", "text_en"))),
                file=context,
            )
            print(file=context)
        print(file=context)
        return bool(collisions)

    print("text_en collisions with same text_de:", file=context)
    collided = print_collision(texts_en, "text_en")

    print("text_de collisions with same text_en:", file=context)
    collided |= print_collision(texts_de, "text_de")

    if collided:
        raise IntegrityError(f"Inconsistent question texts:\n{context.getvalue()}")


class Migration(migrations.Migration):
    """May require manual intervention. Use `check_consistent_question_texts` tool to find inconsistencies."""

    dependencies = [
        ("evaluation", "0158_unified_questions_from_tmp_relation"),
    ]

    operations = [
        migrations.RunPython(check_consistent_question_texts, migrations.RunPython.noop),
        migrations.AlterField(
            model_name="question",
            name="text_de",
            field=models.CharField(max_length=1024, unique=True, verbose_name="question text (german)"),
        ),
        migrations.AlterField(
            model_name="question",
            name="text_en",
            field=models.CharField(max_length=1024, unique=True, verbose_name="question text (english)"),
        ),
    ]
